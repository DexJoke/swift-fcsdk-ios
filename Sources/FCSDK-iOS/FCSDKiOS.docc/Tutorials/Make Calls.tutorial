@Tutorial(time: 90) {
    @Intro(title: "FCSDK Calls") {
        We are now ready to start making calls. Up until this point, our tutorial has assumed you possess basic programmming knowledge and knowledge of the Swift Language. Since the purpose of this tutorial is to show you how to use _FCSDKiOS_ we will now go into detail on how you can use _FCSDK_ with the features you have been looking for. Now that you are experts at creating User interfaces, feel free to reference our UI in order to get up and running. We reccommend that when you are creating your UI, you follow ours closely until you understand how you can work with FCSDK in your own UI. In this Chapter we will cover 3 sections: 
        1. _UIViewControllerRepresentable_
        2. _ACBUC Calls with CallKit_
        3. _Picture in Picture_
    }
    
    @Section(title: "Initializing ACBUC") {
        @ContentAndMedia {
          It has been heavily requested to have an app that uses SwiftUI and FCSDK. This is the reasoning behind our sample app being written in SwiftUI. So, in order to use FCSDK inside of a SwiftUI app, we need to use an API that Apple made for use cases like this. That API is called _UIViewControllerRepresentable_. Its purpose is using _UIKit_ API's within SwiftUI, and since FCSDK Utilizes UIView for displaying Video, this API is perfect for us. So without further ado, let's begin!
        }
        
        @Steps {
            @Step {
               We want to create a directory called _UIViewControllerRepresentable_ inside of the _Shared_ directory. Next, inside of _UIViewControllerRepresentable_ create a file called _CommunicationViewControllerRepresentable_. At the top of the file, import _SwiftUI_ and _UIKit_. Next, I will walk you through building this file in detail.
            }
            
            @Step {
                We need a structure in order to bridge _UIKit_ and _SwiftUI_ and that is the very purpose of this file. So, let's write some code...
            }
            ```swift
            struct CommunicationViewControllerRepresentable: UIViewControllerRepresentable {
            
            }
            ```
            @Step {
               Since we are using `UIViewControllerRepresentable` we need to conform to its protocol. There are 2 methods we must implement.
            }
            ```swift
            
            let communicationViewController: CommunicationViewController
            
            func makeUIViewController(context: UIViewControllerRepresentableContext<CommunicationViewControllerRepresentable>) -> CommunicationViewController {
                return communicationViewController
            }
            ```
            and
            ```swift
            func updateUIViewController(_ uiViewController: CommunicationViewController, context: UIViewControllerRepresentableContext<CommunicationViewControllerRepresentable>) {
            }
            ```
            Once we do that, everything should be happy and our errors should go away. But....
            
            @Step {
                We need something called `CommunicationViewController` in order to _makeUIViewController_.  So let's create a new file in a new group called _UIKit_. This time, we want to do more than create a swift file, we want to create a cocoa touch class. 
                @Image(source: call-001.png, alt: "CococTouch")
            }
            @Step {
                Go ahead and call this UIViewController class _CommunicationViewController_
                @Image(source: call-002.png, alt: "CommunicationViewController")
            }
            
            @Step {
                Next, we are going to start working with UIKit. We won't implement everything we need right now inside this file, but we will get the basics set up and running. To start, let's define some properties.
            }
            
            ```swift
            import FCSDKiOS
            
            class CommunicationViewController: UIViewController {
            var remoteView = SampleBufferVideoCallView()
            var previewView = SamplePreviewVideoCallView()
            
            ......
            }
            ```
            Here, we have our two views that we need in order to display local and remote video. Let's start by talking about previewView. PreviewView subclasses ACBView is _FCSDKiOS_'s UIView that we display our video on. RemoteView also subclasses ACBView. What is important to note about these two UIViews, is that they have the power to override on the views layer and will give us the ability to stream Video during Picture in Picture, but that is a topic for a future discussion.
            @Step {
                Now that we created our two ACBViews (what we need for making video calls) we need to do something with them. We need to add them to the view, give them anchors, and set their size. We can do this inside of a method called `setupUI()`.
            }
            ```swift
            func setupUI() async {
                DispatchQueue.main.async { [weak self] in
                    guard let strongSelf = self else { return }
                    strongSelf.view.addSubview(strongSelf.remoteView)
                    strongSelf.remoteView.addSubview(strongSelf.previewView)
                }
            }
            ```
            Here, we add remoteView to our view and then create a sublayer for our previewView. We want to make sure all of this is always done on the main thread. Next, we want to anchor the views to the proper positions.
            ```swift
            func anchors() async {
                DispatchQueue.main.async { [weak self] in
                    guard let strongSelf = self else { return }

                    strongSelf.remoteView.anchors(top: strongSelf.view.topAnchor, leading: strongSelf.view.leadingAnchor, bottom: strongSelf.view.bottomAnchor, trailing: strongSelf.view.trailingAnchor, paddingTop: 0, paddingLeft: 0, paddingBottom: 0, paddingRight: 0, width: 0, height: 0)

                        strongSelf.previewView.anchors(top: nil, leading: nil, bottom: strongSelf.remoteView.bottomAnchor, trailing: strongSelf.remoteView.trailingAnchor, paddingTop: 0, paddingLeft: 0, paddingBottom: 90, paddingRight: 30, width: 100, height: 300)
                    
                    //Not needed for video display just some custom UI Stuff
                    strongSelf.previewView.samplePreviewDisplayLayer?.videoGravity = .resizeAspectFill
                    strongSelf.previewView.samplePreviewDisplayLayer?.frame = strongSelf.previewView.bounds
                    strongSelf.previewView.samplePreviewDisplayLayer?.masksToBounds = true
                    strongSelf.previewView.samplePreviewDisplayLayer?.cornerRadius = 8
                    strongSelf.view.layoutIfNeeded()
                }
            }
            ```
            The anchors method is a nice extension on UIView that makes constraining views easier. We have provided this as a convieient way to anchor view programatically for you. We also have some setup on the previewView UILayer in order to make it look a bit nicer. Feel free to play around with these settings. We also want to redraw the view if it is needed, as this will be important if we make changes to the UI during the call.

            
                And that's it! That should be all that we need in order to start working with _UIViewControllerRepresntable_.
            @Step {
                Let's move back over to _CommunicationViewControllerRepresentable_ and finish setting it up.
            }
            @Step {
                We have two more properties we need to create. 1. is our call and 2. is a boolean property for picture in picture. We want both of these properties to be bindable so we can pass values down the view hirearchy.
            }
            ```swift 
            @Binding var fcsdkCall: FCSDKCall
            @Binding var pip: Bool
            @Binding var acbuc: ACBUC?
            ```
            We want to make sure we _import FCSDKiOS_
            @Step {
                Next, we need to initialize this structure.
            }
            ```swift
            init(
            fcsdkCall: Binding<FCSDKCall>,
            pip: Binding<Bool>,
            acbuc: Binding<ACBUC?>,
            ) {
                self._fcsdkCall = fcsdkCall
                self._pip = pip
                self._acbuc = acbuc
                communicationViewController = CommunicationViewController()
            }
            ```
            Whenever we initialize _CommunicationViewControllerRepresentable_ we will pass call and pip values to our structure and thus make them available to our _CommunicationViewController_. 
            @Step {
                Everytime we receive new data from _SwiftUI_ we want to pass it to our _UIKit_ _CommunicationViewController_. In order to do that, we can access different methods or properties inside of _CommunicationViewController_ and pass the data off.
            }
            ```swift
            func updateUIViewController(_ uiViewController: CommunicationViewController, context: UIViewControllerRepresentableContext<CommunicationViewControllerRepresentable>) {
                uiViewController.showPip(show: self.pip)
                uiViewController.acbuc = self.acbuc!
            }
            ```
            @Step {
                Excellent work everyone, we are making great progress. If all went well, you should have a structure that looks like this.
                @Image(source: call-003.png, alt: "CommunicationViewControllerRepresentable")
            }
            @Step {
                Now, you can simply call it wherever you need. We will explain how we initialize the call later in this chapter.
            }
            ```swift
            CommunicationViewControllerRepresenable(call: self.$callKitManager.calls.last!, pip: self.$pip)
        ```
        } 
    }
            
    @Section(title: "Setup for CallKit") {
        @ContentAndMedia {
           Now that we have started implementing _UIKit_ inside of _SwiftUI_ we can move forward with the call making process with _CallKit_. We will come back to our UIKit code later, when we have calls and session successfully created, in order to start communicating with people.
        }
        @Steps {
            @Step {
                Create the CallKit Directory in the _Shared_ group, along with the following swift files, _CallKitManager_, _ProviderDelegate_, _ProviderDelegate+Calls_.
                @Image(source: call-004.png, alt: "CallKit")
                
            }
            Since this is a tutorial on making calls, we will let you copy the code from our sample project, and then we will show you how to use it as we progress in the lesson.
            @Step {
                We need to create a model layer. The model layer is very important as it is the representation of all of the calls we make and receive. So, inside the Model Directory, create a file called `FCSDKCall.swift` and then in the ViewModel Directory, create a file called `FCSDKCallViewModel.swift`. They should resemble our model and view model like so.
            }
            ```swift
            final class FCSDKCall: NSObject {

                var handle: String
                var hasVideo: Bool
                var previewView: SamplePreviewVideoCallView? = nil
                var remoteView: SampleBufferVideoCallView? = nil
                var uuid: UUID
                var acbuc: ACBUC
                var call: ACBClientCall? = nil
                
                
                init(
                    handle: String,
                    hasVideo: Bool,
                    previewView: SamplePreviewVideoCallView?,
                    remoteView: SampleBufferVideoCallView?,
                    uuid: UUID,
                    acbuc: ACBUC,
                    call: ACBClientCall? = nil
                ) {
                    self.handle = handle
                    self.hasVideo = hasVideo
                    self.previewView = previewView
                    self.remoteView = remoteView
                    self.uuid = uuid
                    self.acbuc = acbuc
                    self.call = call
                }
            }
            ```
            ```swift
            class FCSDKCallViewModel {
                
                var fcsdkCall: FCSDKCall
                
                init(fcsdkCall: FCSDKCall) {
                    self.fcsdkCall = fcsdkCall
                }
                var handle: String {
                    return fcsdkCall.handle
                }
                var hasVideo: Bool {
                    return fcsdkCall.hasVideo
                }
                var previewView: SamplePreviewVideoCallView? {
                    return fcsdkCall.previewView
                }
                var remoteView: SampleBufferVideoCallView? {
                    return fcsdkCall.remoteView
                }
                var uuid: UUID {
                    return fcsdkCall.uuid
                }
                var acbuc: ACBUC {
                    return fcsdkCall.acbuc
                }
                
                var call: ACBClientCall? {
                    return fcsdkCall.call
                }
            }
            ```
            With the model layer created, we can now use them. Before we do, let's stop for one second and talk about CallKit.
        }
    }
@Section(title: "Working With CallKit") {
    @ContentAndMedia {
        CallKit is an API that Apple gives us that allows us to interact with the native UI when it comes to VoIP apps. For instance, when a user calls, it triggers the native UI like it would if we got a phone call. That is exactly what we will do to demonstrate our calls. The Flow is as Follows: The server sends a signal to your app, then your app tells the iOS to trigger the native UI, then when we answer on the native UI, iOS sends a signal to your app to answer the call. This isn't a comprehnsive tutorial on CallKit, but you can learn from the code here to fully implement CallKit in your app. First, we will write the code to make calls based off of our FCSDKCall model.
        }
     @Steps {
         @Step {
             Let's go ahead and move into CommunicationViewController.swift. We want to write a method that initiates a call, so let's do that.   
         }
         ```swift
         func initiateCall() async {
             let fcsdkCallViewModel = FCSDKCallViewModel(
             fcsdkCall: FCSDKCall(
             handle: self.destination,
             hasVideo: true,
             previewView: self.previewView,
             remoteView: self.remoteView,
             uuid: UUID(),
             acbuc: self.acbuc
             ))
             
             await self.fcsdkCallDelegate?.passCallToService(fcsdkCallViewModel.fcsdkCall)
             await self.callKitManager.initializeCall(fcsdkCallViewModel.fcsdkCall)
         }
         ```
         As you can see, we are creating our call object with the needed data. The properties for the data have not been created yet. We will do that next. Just so you can understand the call flow, I will describe it now. We have a SwiftUI App that consumes FCSDKiOS. Our App needs to use UIKit in order to display our video calls, so we use the API UIViewControllerRepresentable. Our `Communication` View in SwiftUI embeds the UIViewController known as `CommunicationViewController` via `CommunicationViewControllerRepresentable`. Our call method is fired from this ViewController when the view loads and is on an outgoing call. However, our calls have different states - one state could be setup, the other ringing, and another onHold. So, we need some sort of state machine that will deliver different UI and logic depending on the call state. How can we accomplish all of this in an easy straightforward manner? Three things: Our _1. State Machine_, _2.FCSDKCallDelegate_, _3. CallKitManager_. So, let's take these three components one step at a time, starting with _StateMachine_.
     }
    }
}
